# カテゴリの集約
# 所属するデータがあまりにも少ないカテゴリを使って学習を行うと、過学習のリスクが高まります。
# データの少ないカテゴリは、「その他」のようなカテゴリに集約してしまいましょう。

df['currency'].value_counts() 

# USD    21171
# GBP     2486
# EUR     1190
# CAD     1116
# AUD      557
# MXN      139
# SEK      126
# NZD       95
# DKK       80
# NOK       61
# HKD       54
# CHF       42
# SGD       35
# JPY        3
# Name: currency, dtype: int64

# AUD以下のカテゴリはデータ数が少ないことがわかります。よって、ここでは、これらを「Others」としてまとめます。

def others(currency):
    return np.where((currency == 'MXN') | (currency == 'SEK') | (currency == 'NZD') | (currency == 'DKK') |
                    (currency == 'NOK') | (currency == 'HKD') | (currency == 'CHF') | (currency == 'SGD') |
                    (currency == 'JPY'), 'Others', currency)
  
df['currency'] = others(df['currency'])

# df['currency'].value_counts()
# USD       21171
# GBP        2486
# EUR        1190
# CAD        1116
# Others      635
# AUD         557
# Name: currency, dtype: int64



# defにする意味
# 提供されたコードを関数 others(currency) として定義する利点は、以下のような点が考えられます：
# 再利用性: この処理を関数として定義することで、同じ通貨コードの置き換え処理を他の部分で再利用できます。たとえば、複数のデータセットやスクリプトで同じ通貨コードの変換が必要な場合、関数を呼び出すだけで簡単に実行できます。
# 可読性と保守性: コードを関数にまとめることで、処理の目的が明確になり、コード全体の可読性が向上します。また、通貨コードのリストが変更される可能性がある場合、関数内の条件を変更するだけで対応できるため、保守性も高まります。
# テストとデバッグ: 関数を定義すると、単体テストやデバッグが容易に行えます。関数単位で動作を確認できるため、不具合の特定や修正がスムーズに行えます。
# ドキュメンテーション: 関数には通常、ドキュメンテーション文字列（docstring）を追加することが推奨されます。これにより、関数の使い方や引数の説明が記述され、他の開発者が理解しやすくなります。
# したがって、このような単純な条件にも関数を使用することは、コードの構造化、再利用性、保守性、可読性の向上に役立つことがあります。ただし、プログラムの規模や複雑さに合わせて適切なレベルで関数を導入することが重要です。
